<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Teste Camera</title>
</head>
<body>
    
    <video autoplay style="border: 1px solid blue"></video>
    <input type="range">

    <script>
    
        let video = document.querySelector('video');

        navigator.mediaDevices.getUserMedia({video: true})
        .then(async mediaStream => {

            video.srcObject = mediaStream;

            // Once crbug.com/711524 is fixed, we won't need to wait anymore. This is
            // currently needed because capabilities can only be retrieved after the
            // device starts streaming. This happens after and asynchronously w.r.t.
            // getUserMedia() returns.
            await sleep(1000);

            const track = mediaStream.getVideoTracks()[0];
            const capabilities = track.getCapabilities();
            const settings = track.getSettings();

            const input = document.querySelector('input[type="range"]');

            // Check whether zoom is supported or not.
            if (!('zoom' in capabilities)) {
                return Promise.reject('Zoom is not supported by ' + track.label);
            }

            // Map zoom to a slider element.
            input.min = capabilities.zoom.min;
            input.max = capabilities.zoom.max;
            input.step = capabilities.zoom.step;
            input.value = settings.zoom;
            input.oninput = function(event) {
                track.applyConstraints({advanced: [ {zoom: event.target.value} ]});
            }

            input.hidden = false;
        
        }).catch(error => console.log('Argh!', error.name || error));

        /* Utils */
        function sleep(ms = 0) {
            return new Promise(r => setTimeout(r, ms));
        }

    </script>
</body>
</html>